<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高并发——epoll反应堆模型</title>
    <url>/2020/05/16/epoll/</url>
    <content><![CDATA[<p>=========================================================<br>下面代码实现的思想：epoll反应堆模型：（ libevent 网络编程开源库 核心思想）</p>
<p>1.　　普通多路IO转接服务器： 红黑树 ―― 添加待监听的结点 ―― epoll_ctl ―― EPOLLIN ―― fd ―― 监听 ―― epoll_wait ――<a id="more"></a></p>
<p>　　返回满足监听事件的fd的总个数 ―― 传出参数 events数组 ―― 内部元素 ――满足对应监听事件的fd</p>
<p>　　―― 判断对应事件 ―― Accept、Read。――循环 epoll_wait 监听</p>
<p>2.　　epoll反应堆模型： 创建红黑树 ―― 添加监听结点 ―― epoll_ctl ―― EPOLLIN ―― fd ―― 监听 ―― epoll_wait ―― 将结点从树上摘下</p>
<p>　　――处理数据 ―― 修改fd的监听事件 ―― EPOLLOUT ―― 重新添加到红黑树 ―― 监听 ―― epoll_wait ―― 写数据到</p>
<p>　　客户端 ―― 再将结点从树上摘下 ―― 修改监听时间 ―― EPOLLIN ―― 挂上红黑树监听。</p>
<p>　　添加监听写事件的目的： “滑动窗口”已满，绕过写。epoll_wait满足后再进行写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> port 7095</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEVENT 1024 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span>&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd; <span class="comment">//所要监听的文件描述符；</span></span><br><span class="line">	<span class="keyword">int</span> status; <span class="comment">// 是否被挂载在监听红黑树上；</span></span><br><span class="line">	<span class="keyword">void</span> *arg; <span class="comment">// 指向自己的结构体指针；</span></span><br><span class="line">	<span class="keyword">int</span> events; <span class="comment">// 监听事件</span></span><br><span class="line">	<span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> event, <span class="keyword">void</span> *arg); <span class="comment">// 回调函数</span></span><br><span class="line">	<span class="keyword">long</span> last_active;<span class="comment">// 连接时间</span></span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_epfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">BUFSIZ</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventAdd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fcntl</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">	flag |= O_NONBLOCK;</span><br><span class="line">	<span class="keyword">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: fcntl error: %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventSet</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	ev-&gt;fd = fd;</span><br><span class="line">	ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">	ev-&gt;call_back = call_back;</span><br><span class="line">	ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">	ev-&gt;arg = arg;</span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ev-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(ev-&gt;buf));</span><br><span class="line">		ev-&gt;len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ev-&gt;last_active = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventAdd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> op = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	evs.data.ptr = ev;</span><br><span class="line">	evs.events = ev-&gt;events = events;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)&#123;</span><br><span class="line">		op = EPOLL_CTL_ADD;</span><br><span class="line">		ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d is added\n"</span>, ev-&gt;fd);</span><br><span class="line">		<span class="comment">//return;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *str;</span><br><span class="line">	<span class="keyword">if</span>(events == EPOLLIN)&#123;</span><br><span class="line">		str = <span class="string">"EPOLLIN"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(events == EPOLLOUT)&#123;</span><br><span class="line">		str = <span class="string">"EPOLLOUT"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(events == (EPOLLIN | EPOLLET))&#123;</span><br><span class="line">		str = <span class="string">"EPOLLIN | EPOLLET"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = epoll_ctl(g_epfd, op, ev-&gt;fd, &amp;evs);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Events add failed fd[%d], events[%s]\n"</span>, ev-&gt;fd, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Events add OK fd[%d], events[%s]\n"</span>, ev-&gt;fd, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventDel</span><span class="params">(<span class="keyword">int</span> epfd, struct myevent_s *ev)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	evs.data.ptr = <span class="literal">NULL</span>;</span><br><span class="line">	ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">	epoll_ctl(g_epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;evs);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptance</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line">	<span class="keyword">int</span> cfd, i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((cfd = accept(lfd, (struct sockaddr *)&amp;caddr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s:accept,%s\n"</span>,__func__, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFSIZ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(g_events[i].status == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i == BUFSIZ)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Error: too any people\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Fcntl(cfd);</span></span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) <span class="comment">//将cfd也设置为非阻塞</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s: fcntl nonblocking failed, %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		eventSet(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);</span><br><span class="line">		eventAdd(g_epfd, EPOLLIN, &amp;g_events[i]);</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s is connected\n"</span>, inet_ntoa(caddr.sin_addr));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	eventDel(g_epfd, ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		ev-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">		ev-&gt;len = len;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"C[%d]: %s \n"</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">		eventSet(ev, fd, sendData, ev);</span><br><span class="line">		eventAdd(g_epfd, EPOLLOUT, ev);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[fd=%d] pos[%ld], closed\n"</span>, fd, ev-g_events);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s Error: %s \n"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">write</span>(ev-&gt;fd, ev-&gt;buf, ev-&gt;len);</span><br><span class="line"></span><br><span class="line">	eventDel(g_epfd, ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send[fd = %d] [%d] %s\n"</span>, ev-&gt;fd, len, ev-&gt;buf);</span><br><span class="line">		eventSet(ev, fd, recvdata, ev);</span><br><span class="line">		eventAdd(g_epfd, EPOLLIN, ev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s ERROR: %s"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSocket</span><span class="params">(<span class="keyword">int</span> efd)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> lfd, ret;</span><br><span class="line">	<span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">	lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(lfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s create socket error:%s\n"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Fcntl(lfd);</span><br><span class="line"></span><br><span class="line">	saddr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">	saddr.sin_family = AF_INET;</span><br><span class="line">	saddr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">	ret = bind(lfd, (struct sockaddr*)&amp;saddr, len);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s bind error: %s"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	eventSet(&amp;g_events[BUFSIZ], lfd, acceptance, &amp;g_events[BUFSIZ]);</span><br><span class="line">	eventAdd(g_epfd, EPOLLIN, &amp;g_events[BUFSIZ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_epfd = epoll_create(BUFSIZ + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(g_epfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s epoll cteate error: %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	initSocket(g_epfd);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evts</span>[<span class="title">BUFSIZ</span> + 1];</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s:%d is running\n"</span>, IP, port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">ready</span> = epoll_wait(g_epfd, evts, BUFSIZ + <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ready</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">"epoll wait error:"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">ready</span>; ++i)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">evts</span>[<span class="title">i</span>].<span class="title">data</span>.<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>((evts[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))&#123;</span><br><span class="line">				ev-&gt;call_back(ev-&gt;fd, evts[i].events, ev-&gt;arg);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>((evts[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))&#123;</span><br><span class="line">				ev-&gt;call_back(ev-&gt;fd, evts[i].events, ev-&gt;arg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linxu</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>超简单的notepad++使用vim插件方法</title>
    <url>/2020/05/17/install-notepad-visimulator/</url>
    <content><![CDATA[<p>本篇博客仅以记录一个vim党的高兴心情</p>
<p>这段时间一直在学assembly，vim对于assembly的语法高亮十分不友好，被迫下只能使用notepad++但是notepad的操作有点让vim党十分不适，笔者在这里准备了<a href="https://pan.baidu.com/s/1iRQgR6iyPe_HiuMD9JXpSQ" target="_blank" rel="noopener">离线安装包</a>（提取码：bady）<a id="more"></a></p>
<p>下载离线安装包后解压安装包</p>
<p>打开Notepad++选择设置==》导入 ==》导入插件 然后选择解压好的插件重新启动就ok了不需要更改任何配置文件</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>原码 补码 反码 详解</title>
    <url>/2020/05/17/two-s-complement-representation/</url>
    <content><![CDATA[<p>被汇编逼着来学习一波原码反码补码【/捂脸】</p>
<p>在学习源码 反码 补码之前我们先来了解一下什么是机器数和真值</p>
<h4 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h4><p>在计算机中数值都是以二进制形式记录的，那么这个数就是机器数，<a id="more"></a>机器数是有符号数，取最高位表示符号（1为负数0为正数）比如+1表示为机器数是0000 0001 再如-1表示为机器数是1000 0001</p>
<h4 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h4><p>因为计算机中以最高位表示符号所以机器数并不是真整意义上的数，比如-1机器数表示为1000 0001，但是这个数字实际上表示的是129，所以为了区别起见，我们把机器数表示的真实的数字称为真值<br>例如：机器数1000 0001的真值为-1</p>
<h4 id="什么是-原码-反码-补码？【WHAT】"><a href="#什么是-原码-反码-补码？【WHAT】" class="headerlink" title="什么是 原码 反码 补码？【WHAT】"></a>什么是 原码 反码 补码？【WHAT】</h4><p><strong>原码</strong><br>　　原码就是符号位加上真值的绝对值，或者说是机器数<br>例如<br>　    [+1]原 = 0000 0001<br>　    [-1]原 = 1000 0001<br>因为第一位是符号位所以八位原码的表示范围是：<br>　　　　　[1111 1111] ~ [0111 1111]<br>原码是方便人脑理解和计算的一种表示方式</p>
<p><strong>反码</strong><br>　　整数的反码是整数本身<br>　　负数反码就是符号位不变，其余位取反<br>例如<br>　　[+1] = [0000 0001]原 = [0000 0001]反<br>　　[-1] = [1000 0001]原 = [1111 1110]反</p>
<p><strong>补码</strong><br>　　正数的补码是整数本身<br>　　负数的补码是负数的反码加一<br>例如<br>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<h4 id="为什么要使用-原码-补码-反码-【WHY】"><a href="#为什么要使用-原码-补码-反码-【WHY】" class="headerlink" title="为什么要使用 原码 补码 反码 【WHY】"></a>为什么要使用 原码 补码 反码 【WHY】</h4><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>所以不需要过多解释. 但是对于负数:</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>
<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>
<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p>
<p>为了解决原码做减法的问题, 出现了反码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</p>
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.
　　</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>目录和文件的权限</title>
    <url>/2020/05/17/linux-mode/</url>
    <content><![CDATA[<h2 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h2><p>对于stat结构体中的st_mode中不仅仅包含了文件的类型也包含了文件的权限位，st_mode 是一个无符号的八进制数，对于Linux中的7种文件（普通文件、目录文件、块文件、特殊型字符文件、FIFO、套接字、符号链接）<a id="more"></a>均有访问权限，对于只有普通文件才有访问权限这样的认知是错误的，对于每一个文件共有九种权限</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>st_mode屏蔽</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR</td>
<td>用户可读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户可写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户可执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组可读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组可写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组可执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他可读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他可写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他可执行</td>
</tr>
</tbody>
</table>
</div>
<p>那么我们如何使用这些权限屏蔽字？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argvs[])</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input one\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> n = stat(argvs[<span class="number">1</span>], &amp;buf);</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"stat error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IRUSR)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"user can read, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IWUSR)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"user can write, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IXUSR)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"user can execute, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IRGRP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"group can read, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IWGRP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"group can write, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IXGRP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"group can execute, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IROTH)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"other can read, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IWOTH)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"othear can write, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IXOTH)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"other can execute"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在命令行中执行如下命令便可以获得文件权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out 文件名</span><br></pre></td></tr></table></figure>
<p>我们通过逻辑且运算便可以获得权限，那么我们想对一个文件设置权限又该如何进行呢？我们使用逻辑与运算可以设置文件的权限，比如下面的代码可以设置文件可读可写可执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IUWRX (S_IRUSR | S_IWUSR | S_IXUSR)</span></span><br><span class="line">buf-&gt;st_mode | S_IUWRX</span><br></pre></td></tr></table></figure>
<p>如果想清除文件权限也同样可以通过逻辑运算进行,比如如下代码可以清除文件的用户读权限</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buf-&gt;st_mode &amp;~ S_IRUSR</span><br></pre></td></tr></table></figure>
<p>这样设置后的权限仅仅是更改了stat在内存中的值，这样的操作并不会影响内核对权限的检测，也不会自动保存到磁盘中，如需修改至物理磁盘必须再执行chmod</p>
<h2 id="访问权限规则"><a href="#访问权限规则" class="headerlink" title="访问权限规则"></a>访问权限规则</h2><ul>
<li>对于我们使用名字打开的任何一个文件，对该名字包含的每一级目录包括隐藏目录我们都应该具有执行权限</li>
<li>对于我们打开的文件进行性读写操作，这取决于我们对文件的权限拥有</li>
<li>使用open函数O_TRUNC标志时，我们必须对文件具有写权限</li>
<li>在目录下创建一个新的文件时我们必须对目录具有写权限执行权限</li>
<li>删除一个目录中的文件时，我们对该目录必须有写权限执行权限，对于文件本身我们不需要具备任何权限</li>
<li>对于目录的读权限我们只能读取到目录中的文件名，并不能打开文件，如需打开文件我们必须对目录具有执行权限</li>
<li>在对文件权限设置时，我们遵循文件权限最小化</li>
</ul>
<h2 id="访问权限测试"><a href="#访问权限测试" class="headerlink" title="访问权限测试"></a>访问权限测试</h2><p>当我们对文件进行删除，创建，打开操作时会引发内核对权限的测试，测试流程如下</p>
<ol>
<li>若进程的有效用户ID是0（超级管理员）那么则允许访问，这在最大限度上给与超级管理员对文件系统的访问自由</li>
<li>若进程的有效用户ID等于进程的拥有者ID，如果所有者适当的访问权限位被设置则允许访问，否者不允许访问</li>
<li>若进城的有效用户ID或进程的附属组ID之一等于文件的组ID，如果组适当的访问权限被设置则允许访问，否则不允许访问</li>
<li>若其他用户的适当的访问权限被设置则允许访问，否则不允许访问</li>
</ol>
<p>注意的是以上4条队则必须按照顺序执行，也就是说是else if 的关系</p>
<h2 id="access-amp-faccessat-函数"><a href="#access-amp-faccessat-函数" class="headerlink" title="access &amp; faccessat 函数"></a>access &amp; faccessat 函数</h2><p>access 函数和 faccessat 函数是按照实际的用户ID和组ID进行访问权限测试的，步骤也分为四步同上面介绍的一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">																若成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>pathname:文件的绝对路径</p>
<p>mode：如果仅仅是验证文件是否存在的时候设置为F_OK否则按照如下设置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R_OK</td>
<td>测试读权限</td>
</tr>
<tr>
<td>W_OK</td>
<td>测试写权限</td>
</tr>
<tr>
<td>X_OK</td>
<td>测试执行权限</td>
</tr>
</tbody>
</table>
</div>
<p>fd：文件描述符</p>
<p>flag：flag参数可以用于影响faccessat函数的行为，当flag参数设置为E_ACCESS参数时，faccessat函数将按照有效用户id对文件进行权限测试，而不是按照实际的用户id对文件进行测试，</p>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argvs[])</span></span>&#123;</span><br><span class="line">	<span class="comment">//access(const char *pathname, int mode);</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"please input right parameter"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(access(argvs[<span class="number">1</span>], F_OK))&#123;</span><br><span class="line">		perror(<span class="string">"access error for"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"file ok\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(access(argvs[<span class="number">1</span>], R_OK))&#123;</span><br><span class="line">		perror(<span class="string">"access error for"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"read access\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((<span class="built_in">open</span>(argvs[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"reading \n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行中我们输入如下命令测试</p>
<p><img src="https://img-blog.csdnimg.cn/2020051722144736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjAzMTIw,size_16,color_FFFFFF,t_70" style="zoom: 67%;"></p>
]]></content>
      <categories>
        <category>系统编程</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>修改0号中断程序</title>
    <url>/2020/05/18/int0/</url>
    <content><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>任何一个CPU都有一种能力——在执行完成一个指令后检测从CPU内部或者外部传送过来的特殊信息，并立即对该信息进行处理，我们称这种特殊的信息为中断信息，<a id="more"></a>中断的意思是CPU不在继续执行正在执行的指令，转而去处理中断信息，这里所说的中断这是逻辑上的中断，并不是实际上的中断过程，只是便于理解。</p>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p>那么CPU内部出现什么情况时才会产生中断信息呢？对于8086CPU内部出现以下4中情况时会产生中断信息</p>
<ul>
<li>除法错误</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int指令</li>
</ul>
<p>那么既然有不同的事件会导致内部中断，那么对于每一种内部中断我们就都要有与之相对应的程序去处理这种中断事件，既然是不同的事件，那么我们如何区分这不同的事件呢？我们会把每一种中断事件分配一个一个字节的编号，也就是说共有256中表示中断，我们通过编号在中断向量表中寻找中断程序的入口地址，我们要做的就是自己写一个程序并且安装到安全的内存中去，接下来修改中断向量表中的地址，那么下一次程序出错时会自动调用我们的中断程序，其实很多病毒也是这样的设计思路，但是我们千万不要面向监狱编程啊！！！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">entry:</span><br><span class="line">	mov ax, codesg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, offset do0		;设置源地址</span><br><span class="line">	mov ax, 0</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov di, 0200h		;设置目标地址</span><br><span class="line">	</span><br><span class="line">	mov cx, offset do0end - offset do0  ;设置do0程序的长度</span><br><span class="line">	</span><br><span class="line">	cld					;设置正向传输</span><br><span class="line">	rep movsb</span><br><span class="line">	</span><br><span class="line">	mov word ptr es:[0 * 4], 0200H		;设置中断向量表</span><br><span class="line">	mov word ptr es:[0 * 4 + 2], 0000H</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">do0:</span><br><span class="line">	jmp short do0start</span><br><span class="line">	db &#39;haha~~~&#39;</span><br><span class="line">do0start:</span><br><span class="line">	mov ax, cs					; 设置字符串地址</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, 0202H</span><br><span class="line">	</span><br><span class="line">	mov ax, 0B800H				; 设置显存地址</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov di, 160 * 12 + 36 * 2</span><br><span class="line">	</span><br><span class="line">	mov cx, 7					;设置字符串长度</span><br><span class="line"></span><br><span class="line">s0:</span><br><span class="line">	mov al, [si]</span><br><span class="line">	mov es:[di], al				;将字符串写入显存</span><br><span class="line">	</span><br><span class="line">	mov byte ptr es:[di + 1], 2	;设置字符属性</span><br><span class="line">	</span><br><span class="line">	inc di</span><br><span class="line">	inc di</span><br><span class="line">	inc si</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">do0end:							;主要为了计算程序长度</span><br><span class="line">	nop</span><br><span class="line">codesg ends</span><br><span class="line">end entry</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
</search>
