<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>超简单的notepad++使用vim插件方法</title>
    <url>/2020/05/17/install-notepad-visimulator/</url>
    <content><![CDATA[<p>本篇博客仅以记录一个vim党的高兴心情</p>
<p>这段时间一直在学assembly，vim对于assembly的语法高亮十分不友好，被迫下只能使用notepad++但是notepad的操作有点让vim党十分不适，笔者在这里准备了<a href="https://pan.baidu.com/s/1iRQgR6iyPe_HiuMD9JXpSQ" target="_blank" rel="noopener">离线安装包</a>（提取码：bady）<a id="more"></a></p>
<p>下载离线安装包后解压安装包</p>
<p>打开Notepad++选择设置==》导入 ==》导入插件 然后选择解压好的插件重新启动就ok了不需要更改任何配置文件</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发——epoll反应堆模型</title>
    <url>/2020/05/16/epoll/</url>
    <content><![CDATA[<p>=========================================================<br>下面代码实现的思想：epoll反应堆模型：（ libevent 网络编程开源库 核心思想）</p>
<p>1.　　普通多路IO转接服务器： 红黑树 ―― 添加待监听的结点 ―― epoll_ctl ―― EPOLLIN ―― fd ―― 监听 ―― epoll_wait ――<a id="more"></a></p>
<p>　　返回满足监听事件的fd的总个数 ―― 传出参数 events数组 ―― 内部元素 ――满足对应监听事件的fd</p>
<p>　　―― 判断对应事件 ―― Accept、Read。――循环 epoll_wait 监听</p>
<p>2.　　epoll反应堆模型： 创建红黑树 ―― 添加监听结点 ―― epoll_ctl ―― EPOLLIN ―― fd ―― 监听 ―― epoll_wait ―― 将结点从树上摘下</p>
<p>　　――处理数据 ―― 修改fd的监听事件 ―― EPOLLOUT ―― 重新添加到红黑树 ―― 监听 ―― epoll_wait ―― 写数据到</p>
<p>　　客户端 ―― 再将结点从树上摘下 ―― 修改监听时间 ―― EPOLLIN ―― 挂上红黑树监听。</p>
<p>　　添加监听写事件的目的： “滑动窗口”已满，绕过写。epoll_wait满足后再进行写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> port 7095</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEVENT 1024 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span>&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd; <span class="comment">//所要监听的文件描述符；</span></span><br><span class="line">	<span class="keyword">int</span> status; <span class="comment">// 是否被挂载在监听红黑树上；</span></span><br><span class="line">	<span class="keyword">void</span> *arg; <span class="comment">// 指向自己的结构体指针；</span></span><br><span class="line">	<span class="keyword">int</span> events; <span class="comment">// 监听事件</span></span><br><span class="line">	<span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> event, <span class="keyword">void</span> *arg); <span class="comment">// 回调函数</span></span><br><span class="line">	<span class="keyword">long</span> last_active;<span class="comment">// 连接时间</span></span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_epfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">BUFSIZ</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventAdd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fcntl</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">	flag |= O_NONBLOCK;</span><br><span class="line">	<span class="keyword">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: fcntl error: %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventSet</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	ev-&gt;fd = fd;</span><br><span class="line">	ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">	ev-&gt;call_back = call_back;</span><br><span class="line">	ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">	ev-&gt;arg = arg;</span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ev-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(ev-&gt;buf));</span><br><span class="line">		ev-&gt;len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ev-&gt;last_active = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventAdd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> op = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	evs.data.ptr = ev;</span><br><span class="line">	evs.events = ev-&gt;events = events;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)&#123;</span><br><span class="line">		op = EPOLL_CTL_ADD;</span><br><span class="line">		ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d is added\n"</span>, ev-&gt;fd);</span><br><span class="line">		<span class="comment">//return;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *str;</span><br><span class="line">	<span class="keyword">if</span>(events == EPOLLIN)&#123;</span><br><span class="line">		str = <span class="string">"EPOLLIN"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(events == EPOLLOUT)&#123;</span><br><span class="line">		str = <span class="string">"EPOLLOUT"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(events == (EPOLLIN | EPOLLET))&#123;</span><br><span class="line">		str = <span class="string">"EPOLLIN | EPOLLET"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = epoll_ctl(g_epfd, op, ev-&gt;fd, &amp;evs);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Events add failed fd[%d], events[%s]\n"</span>, ev-&gt;fd, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Events add OK fd[%d], events[%s]\n"</span>, ev-&gt;fd, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventDel</span><span class="params">(<span class="keyword">int</span> epfd, struct myevent_s *ev)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	evs.data.ptr = <span class="literal">NULL</span>;</span><br><span class="line">	ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">	epoll_ctl(g_epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;evs);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptance</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line">	<span class="keyword">int</span> cfd, i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((cfd = accept(lfd, (struct sockaddr *)&amp;caddr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s:accept,%s\n"</span>,__func__, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFSIZ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(g_events[i].status == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i == BUFSIZ)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Error: too any people\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Fcntl(cfd);</span></span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) <span class="comment">//将cfd也设置为非阻塞</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s: fcntl nonblocking failed, %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		eventSet(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);</span><br><span class="line">		eventAdd(g_epfd, EPOLLIN, &amp;g_events[i]);</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s is connected\n"</span>, inet_ntoa(caddr.sin_addr));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	eventDel(g_epfd, ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		ev-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">		ev-&gt;len = len;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"C[%d]: %s \n"</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">		eventSet(ev, fd, sendData, ev);</span><br><span class="line">		eventAdd(g_epfd, EPOLLOUT, ev);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[fd=%d] pos[%ld], closed\n"</span>, fd, ev-g_events);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s Error: %s \n"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">write</span>(ev-&gt;fd, ev-&gt;buf, ev-&gt;len);</span><br><span class="line"></span><br><span class="line">	eventDel(g_epfd, ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send[fd = %d] [%d] %s\n"</span>, ev-&gt;fd, len, ev-&gt;buf);</span><br><span class="line">		eventSet(ev, fd, recvdata, ev);</span><br><span class="line">		eventAdd(g_epfd, EPOLLIN, ev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s ERROR: %s"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSocket</span><span class="params">(<span class="keyword">int</span> efd)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> lfd, ret;</span><br><span class="line">	<span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">	lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(lfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s create socket error:%s\n"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Fcntl(lfd);</span><br><span class="line"></span><br><span class="line">	saddr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">	saddr.sin_family = AF_INET;</span><br><span class="line">	saddr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">	ret = bind(lfd, (struct sockaddr*)&amp;saddr, len);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s bind error: %s"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	eventSet(&amp;g_events[BUFSIZ], lfd, acceptance, &amp;g_events[BUFSIZ]);</span><br><span class="line">	eventAdd(g_epfd, EPOLLIN, &amp;g_events[BUFSIZ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_epfd = epoll_create(BUFSIZ + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(g_epfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s epoll cteate error: %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	initSocket(g_epfd);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evts</span>[<span class="title">BUFSIZ</span> + 1];</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s:%d is running\n"</span>, IP, port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">ready</span> = epoll_wait(g_epfd, evts, BUFSIZ + <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ready</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">"epoll wait error:"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">ready</span>; ++i)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">evts</span>[<span class="title">i</span>].<span class="title">data</span>.<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>((evts[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))&#123;</span><br><span class="line">				ev-&gt;call_back(ev-&gt;fd, evts[i].events, ev-&gt;arg);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>((evts[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))&#123;</span><br><span class="line">				ev-&gt;call_back(ev-&gt;fd, evts[i].events, ev-&gt;arg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>目录和文件的权限</title>
    <url>/2020/05/17/linux-mode/</url>
    <content><![CDATA[<h2 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h2><p>对于stat结构体中的st_mode中不仅仅包含了文件的类型也包含了文件的权限位，st_mode 是一个无符号的八进制数，对于Linux中的7种文件（普通文件、目录文件、块文件、特殊型字符文件、FIFO、套接字、符号链接）<a id="more"></a>均有访问权限，对于只有普通文件才有访问权限这样的认知是错误的，对于每一个文件共有九种权限</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>st_mode屏蔽</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR</td>
<td>用户可读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户可写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户可执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组可读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组可写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组可执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他可读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他可写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他可执行</td>
</tr>
</tbody>
</table>
</div>
<p>那么我们如何使用这些权限屏蔽字？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argvs[])</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"please input one\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> n = stat(argvs[<span class="number">1</span>], &amp;buf);</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"stat error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IRUSR)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"user can read, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IWUSR)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"user can write, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IXUSR)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"user can execute, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IRGRP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"group can read, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IWGRP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"group can write, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IXGRP)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"group can execute, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IROTH)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"other can read, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IWOTH)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"othear can write, "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(buf.st_mode &amp; S_IXOTH)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"other can execute"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在命令行中执行如下命令便可以获得文件权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./a.out 文件名</span><br></pre></td></tr></table></figure>
<p>我们通过逻辑且运算便可以获得权限，那么我们想对一个文件设置权限又该如何进行呢？我们使用逻辑与运算可以设置文件的权限，比如下面的代码可以设置文件可读可写可执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IUWRX (S_IRUSR | S_IWUSR | S_IXUSR)</span></span><br><span class="line">buf-&gt;st_mode | S_IUWRX</span><br></pre></td></tr></table></figure>
<p>如果想清除文件权限也同样可以通过逻辑运算进行,比如如下代码可以清除文件的用户读权限</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">buf-&gt;st_mode &amp;~ S_IRUSR</span><br></pre></td></tr></table></figure>
<p>这样设置后的权限仅仅是更改了stat在内存中的值，这样的操作并不会影响内核对权限的检测，也不会自动保存到磁盘中，如需修改至物理磁盘必须再执行chmod</p>
<h2 id="访问权限规则"><a href="#访问权限规则" class="headerlink" title="访问权限规则"></a>访问权限规则</h2><ul>
<li>对于我们使用名字打开的任何一个文件，对该名字包含的每一级目录包括隐藏目录我们都应该具有执行权限</li>
<li>对于我们打开的文件进行性读写操作，这取决于我们对文件的权限拥有</li>
<li>使用open函数O_TRUNC标志时，我们必须对文件具有写权限</li>
<li>在目录下创建一个新的文件时我们必须对目录具有写权限执行权限</li>
<li>删除一个目录中的文件时，我们对该目录必须有写权限执行权限，对于文件本身我们不需要具备任何权限</li>
<li>对于目录的读权限我们只能读取到目录中的文件名，并不能打开文件，如需打开文件我们必须对目录具有执行权限</li>
<li>在对文件权限设置时，我们遵循文件权限最小化</li>
</ul>
<h2 id="访问权限测试"><a href="#访问权限测试" class="headerlink" title="访问权限测试"></a>访问权限测试</h2><p>当我们对文件进行删除，创建，打开操作时会引发内核对权限的测试，测试流程如下</p>
<ol>
<li>若进程的有效用户ID是0（超级管理员）那么则允许访问，这在最大限度上给与超级管理员对文件系统的访问自由</li>
<li>若进程的有效用户ID等于进程的拥有者ID，如果所有者适当的访问权限位被设置则允许访问，否者不允许访问</li>
<li>若进城的有效用户ID或进程的附属组ID之一等于文件的组ID，如果组适当的访问权限被设置则允许访问，否则不允许访问</li>
<li>若其他用户的适当的访问权限被设置则允许访问，否则不允许访问</li>
</ol>
<p>注意的是以上4条队则必须按照顺序执行，也就是说是else if 的关系</p>
<h2 id="access-amp-faccessat-函数"><a href="#access-amp-faccessat-函数" class="headerlink" title="access &amp; faccessat 函数"></a>access &amp; faccessat 函数</h2><p>access 函数和 faccessat 函数是按照实际的用户ID和组ID进行访问权限测试的，步骤也分为四步同上面介绍的一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">																若成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>pathname:文件的绝对路径</p>
<p>mode：如果仅仅是验证文件是否存在的时候设置为F_OK否则按照如下设置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R_OK</td>
<td>测试读权限</td>
</tr>
<tr>
<td>W_OK</td>
<td>测试写权限</td>
</tr>
<tr>
<td>X_OK</td>
<td>测试执行权限</td>
</tr>
</tbody>
</table>
</div>
<p>fd：文件描述符</p>
<p>flag：flag参数可以用于影响faccessat函数的行为，当flag参数设置为E_ACCESS参数时，faccessat函数将按照有效用户id对文件进行权限测试，而不是按照实际的用户id对文件进行测试，</p>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argvs[])</span></span>&#123;</span><br><span class="line">	<span class="comment">//access(const char *pathname, int mode);</span></span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"please input right parameter"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(access(argvs[<span class="number">1</span>], F_OK))&#123;</span><br><span class="line">		perror(<span class="string">"access error for"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"file ok\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(access(argvs[<span class="number">1</span>], R_OK))&#123;</span><br><span class="line">		perror(<span class="string">"access error for"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"read access\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((<span class="built_in">open</span>(argvs[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"reading \n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行中我们输入如下命令测试</p>
<p><img src="https://img-blog.csdnimg.cn/2020051722144736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjAzMTIw,size_16,color_FFFFFF,t_70" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>APUE</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>文件屏蔽字&amp;chmod解读</title>
    <url>/2020/05/19/umask-chmod/</url>
    <content><![CDATA[<p>上一篇blog 我们介绍了9种文件权限位，在这基础上我们介绍与每个进程相关联的文件模式创建屏蔽字</p>
<h2 id="UMASK"><a href="#UMASK" class="headerlink" title="UMASK"></a>UMASK</h2><p>umask 函数为进程设置文件模式创建屏蔽字，并返回之前的值，umask也是少数没有出错返回值的函数，<a id="more"></a>向3这样的函数还有listen（），，，后面会一一讲解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> cmask)</span></span>;</span><br><span class="line">														返回之前的文件模式创建屏蔽字</span><br></pre></td></tr></table></figure>
<p>下面的案例讲解了umask函数的用法，我们不妨运行一下观察一下创建后文件的权限</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rwrwrw (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, n;</span><br><span class="line">	fd = creat(<span class="string">"test.txt"</span>, rwrwrw);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"create0 error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">	fd = creat(<span class="string">"test1.txt"</span>, rwrwrw);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"create1 error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么运行程序后我们不难发现，文件创建时需要的权限位被UMAK设置后则会被拒绝，这样我们可以通过设置umask的值来组织别人向你的文件写入内容</p>
<h2 id="chomd-fchmod-fchmodat"><a href="#chomd-fchmod-fchmodat" class="headerlink" title="chomd     fchmod     fchmodat"></a>chomd     fchmod     fchmodat</h2><p>chmod     fchmod     fchmodat 三个函数主要是用于对文件权限的设置，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">													成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>这里面的mode在原有的九种文件权限位上又添加六种文件权限位，所以共有15种文件权限位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mode</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRWXU</td>
<td>用户可读可写可执行</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>组可读可写可执行</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>其他可续可执行</td>
</tr>
<tr>
<td>S_ISUID</td>
<td>执行时设置用户id</td>
</tr>
<tr>
<td>S_ISGID</td>
<td>执行时设置组id</td>
</tr>
<tr>
<td>S_ISVTX</td>
<td>保存文件粘着位</td>
</tr>
</tbody>
</table>
</div>
<p>这些文件权限位依然通过逻辑运算执行</p>
<p>还记得我们上一章提到过struct stat buf-&gt;st_mode修改之后仅仅是修改了内存中的值并不会影响物理内存中的值，如需对物理内存操作需调用chmod</p>
<p>这里我们通过以下程序来熟悉以下chmod</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	n = stat(<span class="string">"test.txt"</span>, &amp;buf);</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"stat erro"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	n = chmod(<span class="string">"test.txt"</span>, (buf.st_mode &amp; ~S_IXGRP) | S_ISGID);</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"chmod error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>APUE</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>修改0号中断程序</title>
    <url>/2020/05/18/int0/</url>
    <content><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>任何一个CPU都有一种能力——在执行完成一个指令后检测从CPU内部或者外部传送过来的特殊信息，并立即对该信息进行处理，我们称这种特殊的信息为中断信息，<a id="more"></a>中断的意思是CPU不在继续执行正在执行的指令，转而去处理中断信息，这里所说的中断这是逻辑上的中断，并不是实际上的中断过程，只是便于理解。</p>
<h2 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h2><p>那么CPU内部出现什么情况时才会产生中断信息呢？对于8086CPU内部出现以下4中情况时会产生中断信息</p>
<ul>
<li>除法错误</li>
<li>单步执行</li>
<li>执行into指令</li>
<li>执行int指令</li>
</ul>
<p>那么既然有不同的事件会导致内部中断，那么对于每一种内部中断我们就都要有与之相对应的程序去处理这种中断事件，既然是不同的事件，那么我们如何区分这不同的事件呢？我们会把每一种中断事件分配一个一个字节的编号，也就是说共有256中表示中断，我们通过编号在中断向量表中寻找中断程序的入口地址，我们要做的就是自己写一个程序并且安装到安全的内存中去，接下来修改中断向量表中的地址，那么下一次程序出错时会自动调用我们的中断程序，其实很多病毒也是这样的设计思路，但是我们千万不要面向监狱编程啊！！！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">entry:</span><br><span class="line">	mov ax, codesg</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, offset do0		;设置源地址</span><br><span class="line">	mov ax, 0</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov di, 0200h		;设置目标地址</span><br><span class="line">	</span><br><span class="line">	mov cx, offset do0end - offset do0  ;设置do0程序的长度</span><br><span class="line">	</span><br><span class="line">	cld					;设置正向传输</span><br><span class="line">	rep movsb</span><br><span class="line">	</span><br><span class="line">	mov word ptr es:[0 * 4], 0200H		;设置中断向量表</span><br><span class="line">	mov word ptr es:[0 * 4 + 2], 0000H</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">do0:</span><br><span class="line">	jmp short do0start</span><br><span class="line">	db &#39;haha~~~&#39;</span><br><span class="line">do0start:</span><br><span class="line">	mov ax, cs					; 设置字符串地址</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov si, 0202H</span><br><span class="line">	</span><br><span class="line">	mov ax, 0B800H				; 设置显存地址</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov di, 160 * 12 + 36 * 2</span><br><span class="line">	</span><br><span class="line">	mov cx, 7					;设置字符串长度</span><br><span class="line"></span><br><span class="line">s0:</span><br><span class="line">	mov al, [si]</span><br><span class="line">	mov es:[di], al				;将字符串写入显存</span><br><span class="line">	</span><br><span class="line">	mov byte ptr es:[di + 1], 2	;设置字符属性</span><br><span class="line">	</span><br><span class="line">	inc di</span><br><span class="line">	inc di</span><br><span class="line">	inc si</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax, 4c00h</span><br><span class="line">	int 21h</span><br><span class="line">	</span><br><span class="line">do0end:							;主要为了计算程序长度</span><br><span class="line">	nop</span><br><span class="line">codesg ends</span><br><span class="line">end entry</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>文件截断和链接</title>
    <url>/2020/05/20/truncate-link/</url>
    <content><![CDATA[<h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> lenght)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> lenght)</span></span></span><br><span class="line">    							成功返回0，出错返回-1</span><br></pre></td></tr></table></figure>
<p>这两个函数均可以对文件设置截断，如果文件的长度大于length则文件被截断为length，<a id="more"></a>如果文件的长度小于length，那么文件的长度将增加到length，空出的地方以文件空洞补充</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在说明文件链接前我们先讲讲文件系统，这样有利于我们更好的理解文件链接；对于一块磁盘我们可以将其分成若干个分区，对于每一个分区我们都可以采用不同的文件系统，i节点是固定的长度记录项，i节点记录着文件信息。</p>
<p>在实际情况中，可能有若干个目录项指向同一个I节点，每一个i节点都有一个连接数记录器，只有指向i节点的链接数为0时，该i节点记录的文件信息才能被释放，这就是为什么解除文件链接不一定是释放磁盘操作的原因，也是为什么删除目录项函数是unlink而不是delete的原因，在stat结构体中，st_nlink用于记录i节点的文件链接数，这种文件链接我们称之为硬链接，</p>
<p>与硬链接对应的自然有软链接，我们也称之为符号链接，symlink，符号链接文件的实际内容是该符号链接指向的文件的 名称，该文件类型在i节点中是S_IFLINK</p>
<p>i节点包含了与文件有关的所有信息：文件类型，文件长度，文件权限位，指向文件数据块的指针，文件的修改时间等，stat结构体中的信息几乎全部取于i节点中，只有两项重要的数据存放于目录项中：i节点编号，文件名，i节点的数据类型是ino_t</p>
<p>因为i节点编号指向同一个文件系统中的i节点，所以一个目录项不能指向另一个文件系统中的i节点，这也是为什么使用ln命令构建一个指向现有文件的新目录项不能跨越文件系统的原因。</p>
<p>在同一文件系统中为文件重命名时，文件其实并未移动，而是创建一个新的目录项指向i节点，并删除旧的目录项，文件的连接数并未改变，借此我们可以实现mv命令</p>
<p>对于文件系统其实我们可以把它理解为一本书，而i节点则是书的目录</p>
<h2 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#icnlude <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line">													成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>link会根根据patname创建一个名为newpath的硬链接，如果newpath已经存在则返回出错，只能创建newpath最后一个分量，前面的部分应该已经存在，比如newpath = /home/guest/foo.copy 那么 /home/guest 应该已经存在，</p>
<p>对于linkat函数他的oldpath 是由文件描述符合相对路径决定的，比如当前文件存在于/home/guest/01-dir/linkat   nfd指向/home/guest/001.c  而newpathname = ../001.copy 那么该链接文件会被创建在/home/001.copy，如果fd被设置为AT_FDCWD那么相对路径则是相对于当前目录中</p>
<p>flag用于控制linkat的一些操作，当flag被设置为AT_SYMLINK_FOLLOW时，创建的链接为符号链接指向的文件而不是符号链接，</p>
<p>由该函数创建的链接不能跨越文件系统，创建目录项和增加链接计数器是一个原子操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line">									成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>如需删除一个链接，我们使用unlink函数，该函数会使文件的连接数减一，如果文件的连接数减为0则在磁盘上删除改文件，如果还存在其他的文件链接那么通过文件链接依然可以访问改文件，在执行unlink时除了需要该目录的写和执行权限还需要具备以下3个条件之一</p>
<ul>
<li>拥有该目录</li>
<li>拥有该文件</li>
<li>超级管理员</li>
</ul>
<p>若果文件的链接数为0则会删除改文件，但是还有一个条件会阻止文件的删除，那就是有进程打开了改文件，关闭一个文件时，内核首先会检查进程数，如果这个计数器为0，内核会接着检查文件链接，如果文件链接数也为0，那么改文件则会被删除。</p>
<p>flag参数将会控制该函数的操作，如果flag设置为AT_REMOVEDIR则unlink可以删除目录，但是这种操作并不常用</p>
<p>我们来观察一下以下程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd, n;</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">"test"</span>, O_RDWR | O_CREAT, <span class="number">0755</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"open error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n = unlink(<span class="string">"test"</span>);</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">"unlink error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	n = <span class="built_in">write</span>(fd, <span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">5</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"write successed\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		perror(<span class="string">"write error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们运行一下以下程序我们发现我们可以写入成功，并且程序结束后目录中并未有test文件，那么这种操作可以有效地 防止程序意外崩溃后不能删除临时文件。</p>
<p>如果pathname是一个符号链接，那么该操作删除的则是符号链接本身而不是由符号链接指向的文件。</p>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是一个文件的间接指针，符号链接与上文所述的硬链接不同，硬链接是直接指向文件的i节点，引入符号链接则主要是为了避开硬链接的一些限制；</p>
<p>硬链接通常需要在同一文件系统</p>
<p>只有超级管理员可以创建指向目录的硬链接</p>
<p>符号链接则是没有这么多限制，任何用户均可以创建指向目录的链接，也可以分布于不同的文件系统，符号链接一般用于把整个文件或者目录移动到另外一个文件系统，</p>
<p>在使用自函数调用文件链接时应该注意函数是否会跟随符号链接。</p>
<p><img src="https://img-blog.csdnimg.cn/20200521090635716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjAzMTIw,size_16,color_FFFFFF,t_70" style="zoom:67%;" /></p>
<p>需要注意的是创建符号链接时可能会引入死循环（对于查找文件名的函数），比如在test目录下创建一个普通文件和一个指向test目录的符号链接，这样做机会引入死循环</p>
<p>这样的bug是很容易消除的，因为unlink不会跟随符号链接，所以我们只要删除符号链接就ok了，但是如果是硬链接就会比较麻烦了，这也是为什么硬链接不允许创建目录链接的原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpathname, <span class="keyword">const</span> <span class="keyword">char</span> *newpathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpathname, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *newpathname)</span></span>;</span><br><span class="line">													成功返回<span class="number">0</span>，出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>通过以上两个函数我们可以创建一个指向oldpathname的符号链接newpathname，</p>
<p>如果我们使用open函数打开一个符号链接，open函数会跟随到符号链接所指向的文件，但是如果这个文件不存在，则open函数会返回error</p>
<p>那么我们想要读取符号链接的内容怎么办呢？有需求就有生产，我们可以使用符号链接读取函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">ssize_t</span> bufsiz)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">ssize_t</span> bufsiz)</span></span>;</span><br><span class="line">													成功返回读取的字节数，否则返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>两个函数集成了read open close 的所有操作，如果成功则返回读取的字节数。</p>
]]></content>
      <categories>
        <category>APUE</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>原码 补码 反码 详解</title>
    <url>/2020/05/17/two-s-complement-representation/</url>
    <content><![CDATA[<p>被汇编逼着来学习一波原码反码补码【/捂脸】</p>
<p>在学习源码 反码 补码之前我们先来了解一下什么是机器数和真值</p>
<h4 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h4><p>在计算机中数值都是以二进制形式记录的，那么这个数就是机器数，<a id="more"></a>机器数是有符号数，取最高位表示符号（1为负数0为正数）比如+1表示为机器数是0000 0001 再如-1表示为机器数是1000 0001</p>
<h4 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h4><p>因为计算机中以最高位表示符号所以机器数并不是真整意义上的数，比如-1机器数表示为1000 0001，但是这个数字实际上表示的是129，所以为了区别起见，我们把机器数表示的真实的数字称为真值<br>例如：机器数1000 0001的真值为-1</p>
<h4 id="什么是-原码-反码-补码？【WHAT】"><a href="#什么是-原码-反码-补码？【WHAT】" class="headerlink" title="什么是 原码 反码 补码？【WHAT】"></a>什么是 原码 反码 补码？【WHAT】</h4><p><strong>原码</strong><br>　　原码就是符号位加上真值的绝对值，或者说是机器数<br>例如<br>　    [+1]原 = 0000 0001<br>　    [-1]原 = 1000 0001<br>因为第一位是符号位所以八位原码的表示范围是：<br>　　　　　[1111 1111] ~ [0111 1111]<br>原码是方便人脑理解和计算的一种表示方式</p>
<p><strong>反码</strong><br>　　整数的反码是整数本身<br>　　负数反码就是符号位不变，其余位取反<br>例如<br>　　[+1] = [0000 0001]原 = [0000 0001]反<br>　　[-1] = [1000 0001]原 = [1111 1110]反</p>
<p><strong>补码</strong><br>　　正数的补码是整数本身<br>　　负数的补码是负数的反码加一<br>例如<br>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<h4 id="为什么要使用-原码-补码-反码-【WHY】"><a href="#为什么要使用-原码-补码-反码-【WHY】" class="headerlink" title="为什么要使用 原码 补码 反码 【WHY】"></a>为什么要使用 原码 补码 反码 【WHY】</h4><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>所以不需要过多解释. 但是对于负数:</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>
<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>
<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p>
<p>为了解决原码做减法的问题, 出现了反码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</p>
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.
　　</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
</search>
