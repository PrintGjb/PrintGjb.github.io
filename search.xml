<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高并发——epoll反应堆模型</title>
    <url>/2020/05/16/epoll/</url>
    <content><![CDATA[<p>=========================================================<br>下面代码实现的思想：epoll反应堆模型：（ libevent 网络编程开源库 核心思想）</p>
<p>1.　　普通多路IO转接服务器： 红黑树 ―― 添加待监听的结点 ―― epoll_ctl ―― EPOLLIN ―― fd ―― 监听 ―― epoll_wait ――<a id="more"></a></p>
<p>　　返回满足监听事件的fd的总个数 ―― 传出参数 events数组 ―― 内部元素 ――满足对应监听事件的fd</p>
<p>　　―― 判断对应事件 ―― Accept、Read。――循环 epoll_wait 监听</p>
<p>2.　　epoll反应堆模型： 创建红黑树 ―― 添加监听结点 ―― epoll_ctl ―― EPOLLIN ―― fd ―― 监听 ―― epoll_wait ―― 将结点从树上摘下</p>
<p>　　――处理数据 ―― 修改fd的监听事件 ―― EPOLLOUT ―― 重新添加到红黑树 ―― 监听 ―― epoll_wait ―― 写数据到</p>
<p>　　客户端 ―― 再将结点从树上摘下 ―― 修改监听时间 ―― EPOLLIN ―― 挂上红黑树监听。</p>
<p>　　添加监听写事件的目的： “滑动窗口”已满，绕过写。epoll_wait满足后再进行写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP <span class="meta-string">"127.0.0.1"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> port 7095</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXEVENT 1024 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span>&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fd; <span class="comment">//所要监听的文件描述符；</span></span><br><span class="line">	<span class="keyword">int</span> status; <span class="comment">// 是否被挂载在监听红黑树上；</span></span><br><span class="line">	<span class="keyword">void</span> *arg; <span class="comment">// 指向自己的结构体指针；</span></span><br><span class="line">	<span class="keyword">int</span> events; <span class="comment">// 监听事件</span></span><br><span class="line">	<span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> event, <span class="keyword">void</span> *arg); <span class="comment">// 回调函数</span></span><br><span class="line">	<span class="keyword">long</span> last_active;<span class="comment">// 连接时间</span></span><br><span class="line">	<span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_epfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> <span class="title">g_events</span>[<span class="title">BUFSIZ</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventAdd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fcntl</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">	flag |= O_NONBLOCK;</span><br><span class="line">	<span class="keyword">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s: fcntl error: %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventSet</span><span class="params">(struct myevent_s *ev, <span class="keyword">int</span> fd, <span class="keyword">void</span> (*call_back)(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg), <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	ev-&gt;fd = fd;</span><br><span class="line">	ev-&gt;events = <span class="number">0</span>;</span><br><span class="line">	ev-&gt;call_back = call_back;</span><br><span class="line">	ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">	ev-&gt;arg = arg;</span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(ev-&gt;buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(ev-&gt;buf));</span><br><span class="line">		ev-&gt;len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ev-&gt;last_active = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventAdd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> events, struct myevent_s *ev)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">int</span> op = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	evs.data.ptr = ev;</span><br><span class="line">	evs.events = ev-&gt;events = events;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;status == <span class="number">0</span>)&#123;</span><br><span class="line">		op = EPOLL_CTL_ADD;</span><br><span class="line">		ev-&gt;status = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d is added\n"</span>, ev-&gt;fd);</span><br><span class="line">		<span class="comment">//return;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *str;</span><br><span class="line">	<span class="keyword">if</span>(events == EPOLLIN)&#123;</span><br><span class="line">		str = <span class="string">"EPOLLIN"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(events == EPOLLOUT)&#123;</span><br><span class="line">		str = <span class="string">"EPOLLOUT"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(events == (EPOLLIN | EPOLLET))&#123;</span><br><span class="line">		str = <span class="string">"EPOLLIN | EPOLLET"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret = epoll_ctl(g_epfd, op, ev-&gt;fd, &amp;evs);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Events add failed fd[%d], events[%s]\n"</span>, ev-&gt;fd, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Events add OK fd[%d], events[%s]\n"</span>, ev-&gt;fd, str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eventDel</span><span class="params">(<span class="keyword">int</span> epfd, struct myevent_s *ev)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evs</span> = &#123;</span><span class="number">0</span>, &#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">if</span>(ev-&gt;status != <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	evs.data.ptr = <span class="literal">NULL</span>;</span><br><span class="line">	ev-&gt;status = <span class="number">0</span>;</span><br><span class="line">	epoll_ctl(g_epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;evs);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptance</span><span class="params">(<span class="keyword">int</span> lfd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">caddr</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(caddr);</span><br><span class="line">	<span class="keyword">int</span> cfd, i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((cfd = accept(lfd, (struct sockaddr *)&amp;caddr, &amp;len)) == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(errno != EAGAIN &amp;&amp; errno != EINTR)</span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s:accept,%s\n"</span>,__func__, strerror(errno));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; BUFSIZ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(g_events[i].status == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i == BUFSIZ)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Error: too any people\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Fcntl(cfd);</span></span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) &lt; <span class="number">0</span>) <span class="comment">//将cfd也设置为非阻塞</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%s: fcntl nonblocking failed, %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		eventSet(&amp;g_events[i], cfd, recvdata, &amp;g_events[i]);</span><br><span class="line">		eventAdd(g_epfd, EPOLLIN, &amp;g_events[i]);</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s is connected\n"</span>, inet_ntoa(caddr.sin_addr));</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recvdata</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	len = recv(fd, ev-&gt;buf, <span class="keyword">sizeof</span>(ev-&gt;buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	eventDel(g_epfd, ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		ev-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">		ev-&gt;len = len;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"C[%d]: %s \n"</span>, fd, ev-&gt;buf);</span><br><span class="line"></span><br><span class="line">		eventSet(ev, fd, sendData, ev);</span><br><span class="line">		eventAdd(g_epfd, EPOLLOUT, ev);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"[fd=%d] pos[%ld], closed\n"</span>, fd, ev-g_events);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s Error: %s \n"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendData</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">arg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">	len = <span class="built_in">write</span>(ev-&gt;fd, ev-&gt;buf, ev-&gt;len);</span><br><span class="line"></span><br><span class="line">	eventDel(g_epfd, ev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"send[fd = %d] [%d] %s\n"</span>, ev-&gt;fd, len, ev-&gt;buf);</span><br><span class="line">		eventSet(ev, fd, recvdata, ev);</span><br><span class="line">		eventAdd(g_epfd, EPOLLIN, ev);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">close</span>(ev-&gt;fd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s ERROR: %s"</span>, __func__, strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSocket</span><span class="params">(<span class="keyword">int</span> efd)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">	<span class="keyword">int</span> lfd, ret;</span><br><span class="line">	<span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">	lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(lfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s create socket error:%s\n"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Fcntl(lfd);</span><br><span class="line"></span><br><span class="line">	saddr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">	saddr.sin_family = AF_INET;</span><br><span class="line">	saddr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">	len = <span class="keyword">sizeof</span>(saddr);</span><br><span class="line"></span><br><span class="line">	ret = bind(lfd, (struct sockaddr*)&amp;saddr, len);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s bind error: %s"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	eventSet(&amp;g_events[BUFSIZ], lfd, acceptance, &amp;g_events[BUFSIZ]);</span><br><span class="line">	eventAdd(g_epfd, EPOLLIN, &amp;g_events[BUFSIZ]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_epfd = epoll_create(BUFSIZ + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(g_epfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s epoll cteate error: %s\n"</span>, __func__, strerror(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	initSocket(g_epfd);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">evts</span>[<span class="title">BUFSIZ</span> + 1];</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s:%d is running\n"</span>, IP, port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">ready</span> = epoll_wait(g_epfd, evts, BUFSIZ + <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ready</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">"epoll wait error:"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">ready</span>; ++i)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">myevent_s</span> *<span class="title">ev</span> = (<span class="title">struct</span> <span class="title">myevent_s</span> *)<span class="title">evts</span>[<span class="title">i</span>].<span class="title">data</span>.<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>((evts[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN))&#123;</span><br><span class="line">				ev-&gt;call_back(ev-&gt;fd, evts[i].events, ev-&gt;arg);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>((evts[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT))&#123;</span><br><span class="line">				ev-&gt;call_back(ev-&gt;fd, evts[i].events, ev-&gt;arg);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linxu</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>超简单的notepad++使用vim插件方法</title>
    <url>/2020/05/17/install-notepad-visimulator/</url>
    <content><![CDATA[<p>本篇博客仅以记录一个vim党的高兴心情</p>
<p>这段时间一直在学assembly，vim对于assembly的语法高亮十分不友好，被迫下只能使用notepad++但是notepad的操作有点让vim党十分不适，笔者在这里准备了<a href="https://pan.baidu.com/s/1iRQgR6iyPe_HiuMD9JXpSQ" target="_blank" rel="noopener">离线安装包</a>（提取码：bady）</p>
<p>下载离线安装包后解压安装包</p>
<p>打开Notepad++选择设置==》导入 ==》导入插件 然后选择解压好的插件重新启动就ok了不需要更改任何配置文件</p>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>原码 补码 反码 详解</title>
    <url>/2020/05/17/two-s-complement-representation/</url>
    <content><![CDATA[<p>[toc]</p>
<p>被汇编逼着来学习一波原码反码补码【/捂脸】</p>
<p>在学习源码 反码 补码之前我们先来了解一下什么是机器数和真值</p>
<h4 id="机器数"><a href="#机器数" class="headerlink" title="机器数"></a>机器数</h4><p>在计算机中数值都是以二进制形式记录的，那么这个数就是机器数，机器数是有符号数，取最高位表示符号（1为负数0为正数）比如+1表示为机器数是0000 0001 再如-1表示为机器数是1000 0001</p>
<h4 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h4><p>因为计算机中以最高位表示符号所以机器数并不是真整意义上的数，比如-1机器数表示为1000 0001，但是这个数字实际上表示的是129，所以为了区别起见，我们把机器数表示的真实的数字称为真值<br>例如：机器数1000 0001的真值为-1</p>
<h4 id="什么是-原码-反码-补码？【WHAT】"><a href="#什么是-原码-反码-补码？【WHAT】" class="headerlink" title="什么是 原码 反码 补码？【WHAT】"></a>什么是 原码 反码 补码？【WHAT】</h4><p><strong>原码</strong><br>　　原码就是符号位加上真值的绝对值，或者说是机器数<br>例如<br>　    [+1]原 = 0000 0001<br>　    [-1]原 = 1000 0001<br>因为第一位是符号位所以八位原码的表示范围是：<br>　　　　　[1111 1111] ~ [0111 1111]<br>原码是方便人脑理解和计算的一种表示方式</p>
<p><strong>反码</strong><br>　　整数的反码是整数本身<br>　　负数反码就是符号位不变，其余位取反<br>例如<br>　　[+1] = [0000 0001]原 = [0000 0001]反<br>　　[-1] = [1000 0001]原 = [1111 1110]反</p>
<p><strong>补码</strong><br>　　正数的补码是整数本身<br>　　负数的补码是负数的反码加一<br>例如<br>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<h4 id="为什么要使用-原码-补码-反码-【WHY】"><a href="#为什么要使用-原码-补码-反码-【WHY】" class="headerlink" title="为什么要使用 原码 补码 反码 【WHY】"></a>为什么要使用 原码 补码 反码 【WHY】</h4><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p>
<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>
<p>所以不需要过多解释. 但是对于负数:</p>
<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>
<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>
<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p>
<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>
<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p>
<p>为了解决原码做减法的问题, 出现了反码:</p>
<p>计算十进制的表达式: 1-1=0</p>
<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>
<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.</p>
<p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p>
<p>1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>
<p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:</p>
<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>
<p>-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)</p>
<p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].</p>
<p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.
　　</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
</search>
